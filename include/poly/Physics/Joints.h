#ifndef POLY_JOINTS_H
#define POLY_JOINTS_H

#include <poly/Math/Vector2.h>

namespace poly
{


class Physics;


///////////////////////////////////////////////////////////
/// \brief A physics joint constrains certain ranges of motion relative to each other
///
///////////////////////////////////////////////////////////
class Joint
{
	friend Physics;

public:
	///////////////////////////////////////////////////////////
	/// \brief An enum containing the different types of joints
	///
	///////////////////////////////////////////////////////////
	enum Type
	{
		BallAndSocket,		//!< Restricts translational motion, but allows full rotational motion
		Hinge,				//!< Restricts translational motion, and allows rotational motion around a single axis at a certain point
		Slider,				//!< Allows translational motion along a single axis, and restructs rotational motion
		Fixed				//!< Restricts both translational and rotational motion
	};

public:
	///////////////////////////////////////////////////////////
	/// \brief The default constructor
	///
	///////////////////////////////////////////////////////////
	Joint();

	///////////////////////////////////////////////////////////
	/// \brief Set the limits of motion to joints that it applies to
	///
	/// The Type::Hinge and Type::Slider joints are allowed to have
	/// limits to their range of motion.
	///
	/// If the joint has a type of Type::Hinge, then the limit values
	/// must be givin in units of degrees. The minimum hinge value
	/// must be between [-360.0, 0.0] and the maximum hinge value
	/// must be between [0.0, 360.0].
	///
	/// If the joint has a type of Type::Slider, then the limit values
	/// must be given in units of meters. The minimum slider value must
	/// be below zero, and the maximum slider value must be above
	/// zero.
	///
	/// Nothing happens if the joint type is invalid.
	///
	/// \param min The minimum limit value
	/// \param max The maximum limit value
	///
	///////////////////////////////////////////////////////////
	void setLimits(float min, float max);

	///////////////////////////////////////////////////////////
	/// \brief Get the type of joint
	///
	/// \return The joint type
	///
	///////////////////////////////////////////////////////////
	Type getType() const;

	///////////////////////////////////////////////////////////
	/// \brief Get the limits of motions of the joint
	///
	/// This function returns the limits of motion as a 2D vector
	/// where the x-component holds the minimum value and the
	/// y-component holds the maximum value.
	///
	/// \return The joint motion limits
	///
	///////////////////////////////////////////////////////////
	const Vector2f& getLimits() const;

private:
	void setJoint(void* joint, Type type);

private:
	void* m_joint;				//!< The internal joint object
	Type m_type;				//!< The type of joint
	Vector2f m_limits;			//!< The joint limits (for hinge and slider joints)
};


}

#endif


///////////////////////////////////////////////////////////
/// \class poly::Joint
/// \ingroup Physics
///
/// The joint object is used to read and modify the properties
/// of a joint that has already been attached to two entities with
/// rigid body components. Most of the time, the Joint object will
/// be generated by the Physics extension using the Physics::addJoint(),
/// and the returned object can be used to change the joint properties
/// after its initial creation.
///
/// Usage example:
/// \code
///
/// using namespace poly;
///
/// // Create the scene and create a few physics objects
/// Scene scene;
///
/// // Get the physics extension
///	Physics* physics = scene.getExtension<Physics>();
///
/// // Load a box model
/// Model model("models/box.dae");
///
/// std::vector<Entity> entities;
/// for (int i = 0; i < 10; ++i)
/// {
///		RigidBodyComponent rbody;
///		rbody.m_position = Vector3f(0.0f, 5.0f + 2 * i, 0.0f);
///		Entity e = scene.createEntity(TransformComponent(), rbody, RenderComponent(&model), DynamicTag());
///		physics->addCollider(e, BoxShape(1.0f, 1.0f, 1.0f));
///
///		entities.push_back(e);
/// }
///
/// for (int i = 0; i < 10; i += 2)
/// {
///		// Attach joints to every two objects
///		Joint joint = physics.addJoint(entities[i], entities[i + 1], Joint::BallAndSocket, Vector3f(0.0f, 6.0f + 2 * i, 0.0f));
///
///		// Use the joint object
///		...
///
///		// Joints can be removed with:
///		// physics->removeJoint(joint);
///	}
///
/// ...
///
/// \endcode
///
///////////////////////////////////////////////////////////