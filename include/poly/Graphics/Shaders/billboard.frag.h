#ifndef SHADER_BILLBOARD_FRAG
#define SHADER_BILLBOARD_FRAG "#version 330 core\n\nlayout (std140) uniform Camera\n{\n    mat4 u_projView;\n    vec3 u_cameraPos;\n    float u_near;\n    float u_far;\n};\n#define MAX_NUM_MATERIALS 4\n#define MAX_NUM_DIR_LIGHTS 2\n#define MAX_NUM_SHADOW_CASCADES 3\n#define MAX_NUM_SHADOW_MAPS MAX_NUM_DIR_LIGHTS * MAX_NUM_SHADOW_CASCADES\n#define MAX_NUM_POINT_LIGHTS 32\n\n\n///////////////////////////////////////////////////////////\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    bool hasDiffTexture;\n    bool hasSpecTexture;\n    bool hasNormalTexture;\n};\n///////////////////////////////////////////////////////////\nstruct DirLight\n{\n    vec3 diffuse;\n    vec3 specular;\n    vec3 direction;\n};\n\n\n///////////////////////////////////////////////////////////\nstruct PointLight\n{\n    vec3 position;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 coefficients;\n};\n\n\n///////////////////////////////////////////////////////////\nlayout (std140) uniform Lights\n{\n    uniform vec3 u_ambient;\n\n    uniform DirLight u_dirLights[MAX_NUM_DIR_LIGHTS];\n    uniform PointLight u_pointLights[MAX_NUM_POINT_LIGHTS];\n    uniform int u_numDirLights;\n    uniform int u_numPointLights;\n};\n\n\n///////////////////////////////////////////////////////////\nvec3 calcDirLight(DirLight light, Material material, vec3 viewDir, vec3 normal, float shadowFactor, float diffFactor)\n{\n    // Get diffuse factor\n    float diff = dot(normal, -light.direction);\n    float diff1 = diffFactor * diff + diffFactor;\n    float diff2 = (1.0f - diffFactor) * diff + diffFactor;\n    if (diff < 0.0f)\n        diff = diff1;\n    else\n        diff = mix(diff1, diff2, shadowFactor);\n        \n    // Diffuse color\n    vec3 diffuse = diff * light.diffuse * material.diffuse;\n\n    // Get specular factor\n    vec3 reflectDir = reflect(-light.direction, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0f), material.shininess);\n\n    // Specular color\n    vec3 specular = spec * light.specular * material.specular * shadowFactor;\n\n    return diffuse + specular;\n}\n\n\n///////////////////////////////////////////////////////////\nvec3 calcPointLight(PointLight light, Material material, vec3 viewDir, vec3 fragPos, vec3 normal, float diffFactor)\n{\n    vec3 lightDir = fragPos - light.position;\n    float radius = length(lightDir);\n    lightDir /= radius;\n\n    // Calculate attenuation\n    float attenuation = 1.0f / (light.coefficients.x + light.coefficients.y * radius + light.coefficients.z * radius * radius);\n\n    // Get diffuse factor\n    float diff = dot(normal, -lightDir);\n    float diff1 = diffFactor * diff + diffFactor;\n    float diff2 = (1.0f - diffFactor) * diff + diffFactor;\n    diff = (diff < 0.0f ? diff1 : diff2);\n        \n    // Diffuse color\n    vec3 diffuse = diff * light.diffuse * material.diffuse;\n\n    // Get specular factor\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0f), material.shininess);\n\n    // Specular color\n    vec3 specular = spec * light.specular * material.specular;\n\n    return (diffuse + specular) * attenuation;\n}\n///////////////////////////////////////////////////////////\nfloat rand(float c){\n	return fract(sin(c * 12.9898) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat rand(vec2 c){\n	return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////\nvec2 rand2(vec2 st){\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n\n///////////////////////////////////////////////////////////\nvec3 rand3(vec3 st){\n    st = vec3(dot(st, vec3(127.1, 311.7, 285.1)),\n              dot(st, vec3(269.5, 183.3, 161.3)),\n              dot(st, vec3(345.3, 102.9, 245.5)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( rand2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( rand2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( rand2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( rand2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nlayout (std140) uniform Shadows\n{\n    uniform mat4 u_lightProjViews[MAX_NUM_SHADOW_MAPS];\n    uniform float u_shadowDists[MAX_NUM_SHADOW_MAPS];\n    uniform float u_shadowStrengths[MAX_NUM_DIR_LIGHTS];\n    uniform int u_numShadowCascades[MAX_NUM_DIR_LIGHTS];\n    uniform int u_numShadows;\n};\n\n// Shadow functions in the fragment shader\n\n///////////////////////////////////////////////////////////\n\nin vec4 v_clipSpacePos;\nin vec4 v_lightClipSpacePos[MAX_NUM_SHADOW_MAPS];\n\nuniform sampler2D u_shadowMaps[MAX_NUM_SHADOW_MAPS];\n\n\n///////////////////////////////////////////////////////////\nfloat getShadowFactor(int lightNum, vec3 normal, int kernelSize)\n{\n    int lightIndex = lightNum * MAX_NUM_SHADOW_CASCADES;\n\n    // Get correct light parameters\n    int numCascades = u_numShadowCascades[lightIndex];\n    float clipSpaceDepth = v_clipSpacePos.z;\n\n    // Find which region the pixel is in\n    int regionNum = 0;\n    for (; regionNum < numCascades; ++regionNum)\n    {\n        if (clipSpaceDepth < u_shadowDists[lightNum * MAX_NUM_SHADOW_CASCADES + regionNum])\n            break;\n    }\n\n    if (regionNum >= numCascades)\n        return 1.0f;\n\n    int mapIndex = lightIndex + regionNum;\n    vec3 projCoords = v_lightClipSpacePos[mapIndex].xyz / v_lightClipSpacePos[mapIndex].w;\n    projCoords = projCoords * 0.5f + 0.5f;\n\n    // Get shadow map depth\n    float shadow = 0.0f;\n    int kernelHalfSize = (regionNum == 0 ? kernelSize / 2 : 0);\n    vec2 texelSize = 1.0f / textureSize(u_shadowMaps[mapIndex], 0);\n\n    for (int r = -kernelHalfSize; r <= kernelHalfSize; ++r)\n    {\n        for (int c = -kernelHalfSize; c <= kernelHalfSize; ++c)\n        {\n            vec2 texCoords = projCoords.xy / texelSize + vec2(c, r) * 2.0f;\n            vec2 offset = rand2(texCoords * 0.001f);\n            texCoords += (offset - 0.5f);\n\n            float mapDepth = texture(u_shadowMaps[mapIndex], texCoords * texelSize).r;\n            float shadowBias = 0.0001f * (u_shadowDists[mapIndex] / u_shadowDists[lightIndex]) * (2.0f - dot(normal, -u_dirLights[lightNum].direction));\n            shadow += mapDepth < projCoords.z - shadowBias ? 1.0f : 0.0f;\n        }\n    }\n\n    shadow /= pow(2 * kernelHalfSize + 1, 2.0f);\n    \n    return mix(1.0f, 1.0f - shadow, u_shadowStrengths[lightNum]);\n}\n\nin vec3 g_fragPos;\nin vec3 g_normal;\nin vec2 g_texCoord;\n\nout vec4 f_color;\n\nuniform bool u_lightingEnabled;\nuniform bool u_shadowingEnabled;\n\nuniform Material u_materials;\nuniform sampler2D u_diffuseMaps;\nuniform sampler2D u_specularMaps;\nuniform sampler2D u_normalMaps;\n\n\n///////////////////////////////////////////////////////////\nvoid main()\n{\n    Material material = u_materials;\n    \n    // Get diffuse color\n    vec4 diffColor = vec4(material.diffuse, 1.0f);\n    if (material.hasDiffTexture)\n        diffColor *= texture(u_diffuseMaps, g_texCoord);\n\n    vec3 result = diffColor.rgb;\n\n    // Apply lighting if enabled\n    if (u_lightingEnabled)\n    {\n        vec3 viewDir = normalize(g_fragPos - u_cameraPos);\n        \n        // Update material diffuse color\n        material.diffuse = diffColor.rgb;\n\n        // Get specular color\n        if (material.hasSpecTexture)\n            material.specular *= texture(u_specularMaps, g_texCoord).rgb;\n\n        result *= material.ambient * u_ambient;\n        \n        // Calculate directional lighting\n        for (int i = 0; i < u_numDirLights; ++i)\n        {\n            float shadowFactor = 1.0f;\n            if (u_shadowingEnabled)\n                shadowFactor = getShadowFactor(i, 3);\n\n            result += calcDirLight(u_dirLights[i], material, viewDir, g_normal, shadowFactor, 0.1f);\n        }\n    }\n\n    f_color = vec4(result, diffColor.a);\n}"
#endif