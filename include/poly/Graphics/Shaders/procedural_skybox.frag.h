#ifndef SHADER_PROCEDURAL_SKYBOX_FRAG
#define SHADER_PROCEDURAL_SKYBOX_FRAG "#version 330 core\n\nin vec3 v_fragPos;\n\nout vec4 f_color;\n\nuniform vec3 u_zenithColor;\nuniform vec3 u_horizonColor;\nuniform vec3 u_groundColor;\nuniform vec3 u_bloomColor;\nuniform float u_bloomSize;\nuniform float u_lightStrength;\n\nuniform float u_topRadius;\nuniform float u_botRadius;\nuniform float u_radius;\n\nuniform vec3 u_lightDir;\n\nconst float PI = 3.1415926535;\n\n\n///////////////////////////////////////////////////////////\nfloat phaseFunction_R(float nu)\n{\n  float k = 3.0f / (16.0f * PI);\n  return k * (1.0f + nu * nu * 0.5f);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat phaseFunction_M(float g, float nu)\n{\n    float k = 3.0f / (8.0f * PI) * (1.0f - g * g) / (2.0f + g * g);\n    return k * (1.0f + nu * nu) / pow(1.0f + g * g - 2.0f * g * nu, 1.5f);\n}\n\n\n///////////////////////////////////////////////////////////\nvoid main()\n{\n    // Get the view direction\n    vec3 viewDir = normalize(v_fragPos);\n\n    // Get cosine of view direction\n    float mu = dot(viewDir, vec3(0, 1, 0));\n    float nu = dot(viewDir, -u_lightDir);\n\n    // Get distance to top of atmosphere\n    float r = u_radius;\n    float d = -r * mu + sqrt(r * r * (mu * mu - 1.0f) + u_topRadius * u_topRadius);\n    float d_0 = -u_botRadius * mu + sqrt(\n        u_botRadius * u_botRadius * (mu * mu - 1.0f) + u_topRadius * u_topRadius);\n\n    // Get min and max distances\n    float d_min = u_topRadius - r;\n    float distToHorizon = sqrt(r * r - u_botRadius * u_botRadius);\n    float distBotToTop = sqrt(u_topRadius * u_topRadius - u_botRadius * u_botRadius);\n    float d_max = distToHorizon + distBotToTop;\n\n    // Fix ground intersections\n    bool intersectsGround = d > d_max;\n    if (intersectsGround)\n    {\n        d = -r * mu - sqrt(r * r * (mu * mu - 1.0f) + u_botRadius * u_botRadius);\n        d_0 = d;\n    }\n\n    // Calculate mix factor\n    float factor = clamp((d - d_min) / (d_max - d_min), 0.0f, 1.0f);\n    float heightFactor = 1.0f - clamp((r - u_botRadius) / (u_topRadius - u_botRadius), 0.0f, 1.0f);\n\n    vec3 horizonColor = mix(u_zenithColor, u_horizonColor, heightFactor);\n    vec3 color = mix(u_zenithColor, horizonColor, factor) * (d / d_0);\n    if (intersectsGround)\n        color = color * factor * 0.5f + u_groundColor;\n\n    color *= phaseFunction_R(nu) * u_lightStrength;\n\n    // Bloom (mie scattering) effect\n    color += u_bloomColor * phaseFunction_M(u_bloomSize, nu) * (factor * 0.2f + 0.2f) * heightFactor;\n\n    // Final color\n    f_color = vec4(color, 1.0f);\n}"
#endif