#ifndef SHADER_POSTPROCESS_REFLECTIONS_FRAG
#define SHADER_POSTPROCESS_REFLECTIONS_FRAG "#version 330 core\n\nlayout (std140) uniform Camera\n{\n    mat4 u_projView;\n    vec3 u_cameraPos;\n    float u_near;\n    float u_far;\n};\n///////////////////////////////////////////////////////////\nfloat rand(float c){\n	return fract(sin(c * 12.9898) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat rand(vec2 c){\n	return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////\nvec2 rand2(vec2 st){\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n\n///////////////////////////////////////////////////////////\nvec3 rand3(vec3 st){\n    st = vec3(dot(st, vec3(127.1, 311.7, 285.1)),\n              dot(st, vec3(269.5, 183.3, 161.3)),\n              dot(st, vec3(345.3, 102.9, 245.5)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( rand2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( rand2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( rand2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( rand2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nuniform vec3 u_zenithColor;\nuniform vec3 u_horizonColor;\nuniform vec3 u_groundColor;\nuniform vec3 u_scatterColor;\nuniform float u_scatterFactor;\nuniform float u_lightStrength;\n\nuniform float u_topRadius;\nuniform float u_botRadius;\nuniform float u_radius;\n\nuniform vec3 u_lightDir;\n\nconst float PI = 3.1415926535;\n\n\n///////////////////////////////////////////////////////////\nfloat phaseFunction_R(float nu)\n{\n  float k = 3.0f / (16.0f * PI);\n  return k * (1.0f + nu * nu * 0.5f);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat phaseFunction_M(float g, float nu)\n{\n    float k = 3.0f / (8.0f * PI) * (1.0f - g * g) / (2.0f + g * g);\n    return k * (1.0f + nu * nu) / pow(1.0f + g * g - 2.0f * g * nu, 1.5f);\n}\n\n\n///////////////////////////////////////////////////////////\nvec3 getSkyColor(vec3 viewDir)\n{\n    // Get cosine of view direction\n    float mu = dot(viewDir, vec3(0, 1, 0));\n    float nu = dot(viewDir, -u_lightDir);\n\n    // Get distance to top of atmosphere\n    float r = u_radius;\n    float d = -r * mu + sqrt(r * r * (mu * mu - 1.0f) + u_topRadius * u_topRadius);\n    float d_0 = -u_botRadius * mu + sqrt(\n        u_botRadius * u_botRadius * (mu * mu - 1.0f) + u_topRadius * u_topRadius);\n\n    // Get min and max distances\n    float d_min = u_topRadius - r;\n    float distToHorizon = sqrt(r * r - u_botRadius * u_botRadius);\n    float distBotToTop = sqrt(u_topRadius * u_topRadius - u_botRadius * u_botRadius);\n    float d_max = distToHorizon + distBotToTop;\n\n    // Fix ground intersections\n    bool intersectsGround = d > d_max;\n    if (intersectsGround)\n    {\n        d = -r * mu - sqrt(r * r * (mu * mu - 1.0f) + u_botRadius * u_botRadius);\n        d_0 = d;\n    }\n\n    // Calculate mix factor\n    float factor = clamp((d - d_min) / (d_max - d_min), 0.0f, 1.0f);\n    float heightFactor = 1.0f - clamp((r - u_botRadius) / (u_topRadius - u_botRadius), 0.0f, 1.0f);\n\n    vec3 horizonColor = mix(u_zenithColor, u_horizonColor, heightFactor);\n    vec3 color = mix(u_zenithColor, horizonColor, factor) * (d / d_0);\n    if (intersectsGround)\n        color = color * factor * 0.5f + u_groundColor;\n\n    color *= phaseFunction_R(nu) * u_lightStrength;\n\n    // scatter (mie scattering) effect\n    color += u_scatterColor * phaseFunction_M(u_scatterFactor, nu) * pow(d / d_max, 0.8f) * heightFactor;\n\n    return color;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nin vec2 v_texCoord;\n\nout vec4 f_color;\n\nuniform sampler2D u_color;\nuniform sampler2D u_normalShininess;\nuniform sampler2D u_specularReflectivity;\nuniform sampler2D u_depth;\n\nuniform mat4 u_invProjView;\nuniform bool u_usesProceduralSkybox;\n\nuniform float u_maxDistance;\nuniform float u_stepSize;\nuniform float u_thickness;\nuniform float u_maxDepthDiff;\nuniform float u_noiseFactor;\nuniform float u_fresnelFactor;\n\n\n///////////////////////////////////////////////////////////////////////////////\nfloat getLinearDepth(float d)\n{\n    float z_n = 2.0 * d - 1.0;\n    return 2.0 * u_near * u_far / (u_far + u_near - z_n * (u_far - u_near));\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\nvec3 getFragPosFromDepth(vec2 uv, float depth)\n{\n    vec4 clipPos = vec4(2.0f * uv - 1.0f, 2.0f * depth - 1.0f, 1.0f);\n    vec4 pos = u_invProjView * clipPos;\n\n    return pos.xyz / pos.w;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\nvec3 getFragPos(vec2 uv, out float depth)\n{\n    depth = texture(u_depth, uv).r;\n    return getFragPosFromDepth(uv, depth);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\nvec3 worldToUV(vec3 world)\n{\n    vec4 clipSpace = u_projView * vec4(world, 1.0f);\n    return clamp((clipSpace.xyz / clipSpace.w) * 0.5f + 0.5f, 0.0f, 1.0f);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\nbool raycast(vec3 position, float depth, vec3 ray, out vec3 rayTexCoord)\n{\n    // Get endpoints in texture coords\n    vec3 startTexCoords = vec3(v_texCoord, depth);\n    vec3 endTexCoords = worldToUV(position + u_maxDistance * ray);\n\n    // Calculate increment size\n    vec2 texSize = textureSize(u_depth, 0).xy;\n    float segmentLength = distance(endTexCoords.xy, startTexCoords.xy);\n    vec2 increment = u_stepSize / texSize * ((endTexCoords.xy - startTexCoords.xy) / segmentLength);\n    float incrementLength = length(increment);\n\n    if (incrementLength > segmentLength)\n    {\n        increment *= segmentLength / incrementLength;\n        incrementLength = segmentLength;\n    }\n    \n    // Raycast\n    rayTexCoord = startTexCoords;\n    bool hit = false;\n\n    // Keep track of increment endpoints for binary search later\n    vec3 endpoint1, endpoint2;\n\n    for (float rayLength = 0.0f; rayLength < segmentLength; rayLength += incrementLength)\n    {\n        rayTexCoord.xy += increment;\n\n        // Get percentage of the ray that has been travelled\n        float percent = (rayTexCoord.x - startTexCoords.x) / (endTexCoords.x - startTexCoords.x);\n\n        // Get ray depth by interpolating depth\n        rayTexCoord.z = (startTexCoords.z * endTexCoords.z) / mix(endTexCoords.z, startTexCoords.z, percent);\n\n        // Get depth of the pixel\n        depth = texture(u_depth, rayTexCoord.xy).r;\n\n        // Get linear depths\n        float rayDepthLinear = getLinearDepth(rayTexCoord.z);\n        float depthLinear = getLinearDepth(depth);\n        float depthDiff = rayDepthLinear - depthLinear;\n\n        // Check for intersection\n        if (depthDiff > 0.0f && depthDiff < u_thickness)\n        {\n            endpoint2 = rayTexCoord;\n            hit = true;\n            break;\n        }\n\n        endpoint1 = rayTexCoord;\n    }\n\n    if (hit)\n    {\n        float depth = 0.0f;\n\n        // Binary search to find accurate position\n        for (int i = 0; i < 5; ++i)\n        {\n            // Get midpoint\n            vec3 midpoint = mix(endpoint1, endpoint2, 0.5f);\n            midpoint.z = (endpoint1.z * endpoint2.z) / mix(endpoint2.z, endpoint1.z, 0.5f);\n            rayTexCoord = midpoint;\n\n            // Get depth of the pixel\n            depth = texture(u_depth, midpoint.xy).r;\n\n            if (depth < rayTexCoord.z)\n                // The fragment is in front of the ray\n                endpoint2 = midpoint;\n            else\n                // The ray is in front of the fragment\n                endpoint1 = midpoint;\n        }\n\n        // Make sure the hit is valid\n        vec3 hitNormal = texture(u_normalShininess, rayTexCoord.xy).xyz;\n\n        hit =\n            abs(getLinearDepth(depth) - getLinearDepth(rayTexCoord.z)) < u_maxDepthDiff &&\n            dot(ray, hitNormal) < 0.0f;\n    }\n\n    return hit;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\nvoid main()\n{\n    float depth = 0.0f;\n    vec3 position = getFragPos(v_texCoord, depth);\n    vec3 color = texture(u_color, v_texCoord).rgb;\n    float reflectivity = texture(u_specularReflectivity, v_texCoord).a;\n    f_color = vec4(color, 1.0f);\n\n    // Check if the reflectivity is above 0 and not the skybox\n    if (depth >= 1.0f || reflectivity == 0.0f)\n        return;\n\n    // Offset position by a random amount\n    position += rand3(position) * u_noiseFactor - 0.5f * u_noiseFactor;\n\n    // Get normal and reflected view vector\n    vec3 normal = texture(u_normalShininess, v_texCoord).rgb;\n    vec3 viewDir = normalize(position - u_cameraPos);\n    vec3 reflectedRay = normalize(reflect(viewDir, normal));\n    \n    // Raycast\n    vec3 rayTexCoord;\n    bool hit = raycast(position, depth, reflectedRay, rayTexCoord);\n\n    // Get color of reflection\n    vec3 reflColor;\n    if (hit)\n        reflColor = texture(u_color, rayTexCoord.xy).rgb;\n\n    else\n    {\n        // Take color from skybox\n        if (u_usesProceduralSkybox)\n        {\n            // Make sure reflected ray doesn't go below horizon\n            if (reflectedRay.y < 0.0f)\n                reflectedRay = normalize(vec3(reflectedRay.x, 0.0f, reflectedRay.z));\n\n            reflColor = getSkyColor(reflectedRay);\n        }\n    }\n\n    // Apply the fresnel effect\n    float reflFactor = (1.0f - pow(max(dot(-viewDir, normal), 0.0f), u_fresnelFactor)) * reflectivity;\n    reflColor = mix(color, reflColor, reflFactor);\n\n    f_color = vec4(reflColor, 1.0f);\n}"
#endif