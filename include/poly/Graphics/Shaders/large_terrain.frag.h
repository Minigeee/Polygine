#ifndef SHADER_LARGE_TERRAIN_FRAG
#define SHADER_LARGE_TERRAIN_FRAG "#version 330 core\n\nlayout (std140) uniform Camera\n{\n    mat4 u_projView;\n    vec3 u_cameraPos;\n    float u_near;\n    float u_far;\n};\n#define MAX_NUM_MATERIALS 4\n#define MAX_NUM_DIR_LIGHTS 2\n#define MAX_NUM_SHADOW_CASCADES 3\n#define MAX_NUM_SHADOW_MAPS MAX_NUM_DIR_LIGHTS * MAX_NUM_SHADOW_CASCADES\n#define MAX_NUM_POINT_LIGHTS 100\n\n\n///////////////////////////////////////////////////////////\nstruct Material\n{\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float occlusion;\n    float reflectivity;\n    bool hasDiffTexture;\n    bool hasSpecTexture;\n    bool hasNormalTexture;\n};\n\nlayout (location = 0) out vec4 f_normalShininess;\nlayout (location = 1) out vec4 f_albedoOcclusion;\nlayout (location = 2) out vec4 f_specularReflectivity;\n\n\n///////////////////////////////////////////////////////////\nvoid deferred(Material material, vec3 normal)\n{\n    f_normalShininess = vec4(normal, material.shininess);\n    f_albedoOcclusion = vec4(material.diffuse, material.occlusion);\n    f_specularReflectivity = vec4(material.specular, material.reflectivity);\n}\nuniform vec2 u_cacheMapSize;\nuniform sampler2D u_redirectMap;\n\n\n///////////////////////////////////////////////////////////\nvec3 sampleRedirectData(vec2 uv)\n{\n    return round(texture(u_redirectMap, uv).xyz * 255.0f);\n}\n\n\n///////////////////////////////////////////////////////////\nvec4 sample(sampler2D tex, vec2 uv, vec3 redirect)\n{\n    // Redirect data\n    vec2 cachePos = redirect.xy;\n    float scaleExp = redirect.z;\n\n    // Calculate tile resolution\n    vec2 cacheTexSize = textureSize(tex, 0);\n    float tileRes = cacheTexSize.x / u_cacheMapSize.x;\n\n    // Calculate tile coordinates\n    float tileScale = pow(2.0f, scaleExp);\n    vec2 tileCoords = fract(uv * vec2(textureSize(u_redirectMap, 0)) / tileScale);\n    tileCoords = (tileCoords * (tileRes - 2.0f) + 1.0f) / tileRes;\n\n    // Calculate cache coordinates\n    vec2 cacheCoords = tileRes * (cachePos + tileCoords) / cacheTexSize;\n\n    // Sample cache texture\n    return texture(tex, cacheCoords);\n}\n\n\n///////////////////////////////////////////////////////////\nvec4 sample(sampler2D tex, vec2 uv)\n{\n    return sample(tex, uv, sampleRedirectData(uv));\n}\n\n\n///////////////////////////////////////////////////////////\nvec4 sampleBase(sampler2D tex, vec2 uv)\n{\n    // Base texture should always be at (0, 0) tile\n    vec2 texSize = textureSize(tex, 0);\n    float tileRes = texSize.x / u_cacheMapSize.x;\n    vec2 cacheCoords = (uv * (tileRes - 2.0f) + 1.0f) / texSize;\n\n    // Sample cache texture\n    return texture(tex, cacheCoords);\n}\n\n///////////////////////////////////////////////////////////\n\nin vec3 v_fragPos;\nin vec2 v_texCoord;\n\nuniform sampler2D u_normalMap;\n\n///////////////////////////////////////////////////////////\n\nvoid main()\n{\n    // Get texture redirect data\n    vec3 redirect = sampleRedirectData(v_texCoord);\n\n    vec3 normal = sample(u_normalMap, v_texCoord, redirect).xyz;\n    normal.xz = 2.0f * normal.xz - 1.0f;\n    vec3 color = vec3(0.4f, 0.8f, 0.4f);\n\n    // Create terrain material\n    Material material;\n    material.diffuse = color;\n    material.specular = vec3(0.2f);\n    material.shininess = 2.0f;\n    material.occlusion = 1.0f;\n    material.reflectivity = 0.0f;\n    \n    // Output to color buffers\n    deferred(material, normal);\n}"
#endif