#ifndef SHADER_TERRAIN_VERT
#define SHADER_TERRAIN_VERT "#version 330 core\n\nlayout (std140) uniform Camera\n{\n    mat4 u_projView;\n    vec3 u_cameraPos;\n    float u_near;\n    float u_far;\n};\n///////////////////////////////////////////////////////////\n\nuniform vec4 u_clipPlanes[8];\nuniform int u_numClipPlanes;\n\nfloat gl_ClipDistance[8];\n\n///////////////////////////////////////////////////////////\n\nvoid applyClipPlanes(vec3 pos)\n{\n    for (int i = 0; i < u_numClipPlanes; ++i)\n        gl_ClipDistance[i] = dot(u_clipPlanes[i], vec4(pos, 1.0f));\n}\n\nlayout (location = 0) in vec2 a_position;\nlayout (location = 1) in vec2 a_nearTexCoord;\nlayout (location = 2) in vec2 a_farTexCoord;\nlayout (location = 3) in float a_lodDist;\nlayout (location = 4) in mat4 a_transform;\n\nout vec3 v_fragPos;\nout vec3 v_normal;\nout vec3 v_color;\nflat out int v_chunk;\n\nlayout (std140) uniform Terrain\n{\n    uniform float u_chunkSize;\n    uniform float u_maxHeight;\n    uniform float u_tileScale;\n    uniform float u_blendLodDist;\n    uniform bool u_useFlatShading;\n};\n\nuniform sampler2D u_normalMaps[9];\nuniform sampler2D u_colorMaps[9];\nuniform sampler2D u_heightMaps[9];\n\nvoid main()\n{\n    vec4 worldPos = a_transform * vec4(a_position.x, 0.0f, a_position.y, 1.0f);\n\n    // Get chunk offset\n    vec2 terrainCenter = round(u_cameraPos.xz / u_chunkSize) * u_chunkSize;\n    vec2 chunkCenter = round(worldPos.xz / u_chunkSize) * u_chunkSize;\n    vec2 chunkOffset = chunkCenter - terrainCenter;\n    float halfChunkSize = 0.5f * u_chunkSize;\n\n    v_chunk = 4;\n    if (chunkOffset.x > halfChunkSize)\n        v_chunk += 3;\n    else if (chunkOffset.x < -halfChunkSize)\n        v_chunk -= 3;\n    if (chunkOffset.y > halfChunkSize)\n        v_chunk += 1;\n    else if (chunkOffset.y < -halfChunkSize)\n        v_chunk -= 1;\n\n    // Get texture coordinate\n    vec2 mapSize = textureSize(u_heightMaps[v_chunk], 0);\n    vec2 texCoord = clamp((worldPos.xz - chunkCenter) / u_chunkSize + 0.5f, 0.0f, 1.0f);\n    texCoord = (mapSize - 1.0f) / mapSize * texCoord + 0.5f / mapSize;\n\n    // Calculate height\n    worldPos.y = texture(u_heightMaps[v_chunk], texCoord).r * u_maxHeight;\n\n    gl_Position =  u_projView * worldPos;\n    \n    if (u_useFlatShading)\n    {\n        vec3 normal, color;\n\n        // Calculate texture coordinate\n        float dist = max(abs(u_cameraPos.x - worldPos.x), abs(u_cameraPos.z - worldPos.z));\n\n        if (dist < u_blendLodDist)\n        {\n            vec2 nearTexCoord = (a_transform * vec4(a_nearTexCoord.x, 0.0f, a_nearTexCoord.y, 1.0f)).xz;\n            vec2 farTexCoord = (a_transform * vec4(a_farTexCoord.x, 0.0f, a_farTexCoord.y, 1.0f)).xz;\n\n            float factor = (dist - (a_lodDist - 4.0f * u_tileScale)) / (4.0f * u_tileScale);\n            factor = clamp(factor, 0.0f, 1.0f);\n\n            texCoord = mix(nearTexCoord, farTexCoord, factor);\n            texCoord = fract((texCoord - chunkCenter) / u_chunkSize + 0.5f);\n\n            normal = texture(u_normalMaps[v_chunk], texCoord).rgb;\n            color = texture(u_colorMaps[v_chunk], texCoord).rgb;\n        }\n        else\n        {\n            vec2 nearTexCoord = (a_transform * vec4(a_nearTexCoord.x, 0.0f, a_nearTexCoord.y, 1.0f)).xz;\n            nearTexCoord = fract((nearTexCoord - chunkCenter) / u_chunkSize + 0.5f);\n\n            normal = texture(u_normalMaps[v_chunk], texCoord).rgb * 0.3;\n            normal += texture(u_normalMaps[v_chunk], nearTexCoord).rgb * 0.7;\n            color = texture(u_colorMaps[v_chunk], texCoord).rgb;\n        }\n\n        v_normal = normal;\n        v_color = color;\n    }\n\n    // Apply clip planes\n    applyClipPlanes(worldPos.xyz);\n\n    v_fragPos = worldPos.xyz;\n}"
#endif