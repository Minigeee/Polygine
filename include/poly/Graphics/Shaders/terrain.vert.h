#ifndef SHADER_TERRAIN_VERT
#define SHADER_TERRAIN_VERT "#version 330 core\n\nlayout (std140) uniform Camera\n{\n    mat4 u_projView;\n    vec3 u_cameraPos;\n    float u_near;\n    float u_far;\n};\n///////////////////////////////////////////////////////////\n\nuniform vec4 u_clipPlanes[8];\nuniform int u_numClipPlanes;\n\nfloat gl_ClipDistance[8];\n\n///////////////////////////////////////////////////////////\n\nvoid applyClipPlanes(vec3 pos)\n{\n    for (int i = 0; i < u_numClipPlanes; ++i)\n        gl_ClipDistance[i] = dot(u_clipPlanes[i], vec4(pos, 1.0f));\n}\n#define MAX_NUM_MATERIALS 4\n#define MAX_NUM_DIR_LIGHTS 2\n#define MAX_NUM_SHADOW_CASCADES 3\n#define MAX_NUM_SHADOW_MAPS MAX_NUM_DIR_LIGHTS * MAX_NUM_SHADOW_CASCADES\n#define MAX_NUM_POINT_LIGHTS 100\n\n\n///////////////////////////////////////////////////////////\nstruct Material\n{\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float occlusion;\n    float reflectivity;\n    bool hasDiffTexture;\n    bool hasSpecTexture;\n    bool hasNormalTexture;\n};\nlayout (std140) uniform Shadows\n{\n    uniform mat4 u_lightProjViews[MAX_NUM_SHADOW_MAPS];\n    uniform float u_shadowDists[MAX_NUM_SHADOW_MAPS];\n    uniform float u_shadowStrengths[MAX_NUM_DIR_LIGHTS];\n    uniform int u_numShadowCascades[MAX_NUM_DIR_LIGHTS];\n    uniform bool u_shadowsEnabled[MAX_NUM_DIR_LIGHTS];\n};\n\n// Set up shadows in the vertex shader\n\n///////////////////////////////////////////////////////////\n\n#ifndef DEFERRED_SHADING\nout vec4 v_clipSpacePos;\nout vec4 v_lightClipSpacePos[MAX_NUM_SHADOW_MAPS];\n#else\nvec4 v_clipSpacePos;\nvec4 v_lightClipSpacePos[MAX_NUM_SHADOW_MAPS];\n#endif\n\n\n///////////////////////////////////////////////////////////\nvoid calcShadowClipSpace(vec4 worldPos)\n{\n    #ifndef DEFERRED_SHADING\n    v_clipSpacePos = gl_Position;\n    #else\n    v_clipSpacePos = u_projView * worldPos;\n    #endif\n\n    // Calculate light space positions\n    for (int i = 0; i < MAX_NUM_DIR_LIGHTS; ++i)\n    {\n        if (u_shadowsEnabled[i])\n        {\n            int start = i * MAX_NUM_SHADOW_CASCADES;\n            int end = start + MAX_NUM_SHADOW_CASCADES;\n\n            for (int j = start; j < end; ++j)\n                v_lightClipSpacePos[j] = u_lightProjViews[j] * worldPos;\n        }\n    }\n}\n\nlayout (location = 0) in vec2 a_position;\nlayout (location = 1) in vec2 a_nearTexCoord;\nlayout (location = 2) in vec2 a_farTexCoord;\nlayout (location = 3) in float a_lodDist;\nlayout (location = 4) in mat4 a_transform;\n\nout vec3 v_fragPos;\nout vec3 v_normal;\nout vec3 v_color;\nout vec2 v_texCoord;\n\nlayout (std140) uniform Terrain\n{\n    uniform float u_size;\n    uniform float u_height;\n    uniform float u_tileScale;\n    uniform float u_blendLodDist;\n    uniform bool u_useFlatShading;\n};\n\nuniform sampler2D u_normalMap;\nuniform sampler2D u_colorMap;\n\nuniform sampler2D u_heightMap;\n\nvoid main()\n{\n    vec4 worldPos = a_transform * vec4(a_position.x, 0.0f, a_position.y, 1.0f);\n\n    // Calculate height\n    v_texCoord = worldPos.xz / u_size + 0.5f;\n    worldPos.y = texture(u_heightMap, v_texCoord).r * u_height;\n\n    gl_Position =  u_projView * worldPos;\n    v_clipSpacePos = gl_Position;\n    \n    if (u_useFlatShading)\n    {\n        vec3 normal, color;\n\n        // Calculate texture coordinate\n        float dist = max(abs(u_cameraPos.x - worldPos.x), abs(u_cameraPos.z - worldPos.z));\n\n        if (dist < u_blendLodDist)\n        {\n            vec2 nearTexCoord = (a_transform * vec4(a_nearTexCoord.x, 0.0f, a_nearTexCoord.y, 1.0f)).xz;\n            vec2 farTexCoord = (a_transform * vec4(a_farTexCoord.x, 0.0f, a_farTexCoord.y, 1.0f)).xz;\n\n            float factor = (dist - (a_lodDist - 4.0f * u_tileScale)) / (4.0f * u_tileScale);\n            factor = clamp(factor, 0.0f, 1.0f);\n\n            vec2 texCoord = mix(nearTexCoord, farTexCoord, factor);\n            texCoord = texCoord / u_size + 0.5f;\n\n            normal = texture(u_normalMap, texCoord).rgb;\n            color = texture(u_colorMap, texCoord).rgb;\n        }\n        else\n        {\n            vec2 nearTexCoord = (a_transform * vec4(a_nearTexCoord.x, 0.0f, a_nearTexCoord.y, 1.0f)).xz;\n\n            normal = texture(u_normalMap, worldPos.xz / u_size + 0.5f).rgb * 0.3;\n            normal += texture(u_normalMap, nearTexCoord / u_size + 0.5f).rgb * 0.7;\n            color = texture(u_colorMap, worldPos.xz / u_size + 0.5f).rgb;\n        }\n\n        v_normal = normal;\n        v_color = color;\n    }\n\n    // Apply clip planes\n    applyClipPlanes(worldPos.xyz);\n\n    v_fragPos = worldPos.xyz;\n\n    // Set up output variables for shadows\n    calcShadowClipSpace(worldPos);\n}"
#endif