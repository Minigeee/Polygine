#ifndef SHADER_DEFERRED_FRAG
#define SHADER_DEFERRED_FRAG "#version 330 core\n\n#define DEFERRED_SHADING\n\nlayout (std140) uniform Camera\n{\n    mat4 u_projView;\n    vec3 u_cameraPos;\n    float u_near;\n    float u_far;\n};\n#define MAX_NUM_MATERIALS 4\n#define MAX_NUM_DIR_LIGHTS 2\n#define MAX_NUM_SHADOW_CASCADES 3\n#define MAX_NUM_SHADOW_MAPS MAX_NUM_DIR_LIGHTS * MAX_NUM_SHADOW_CASCADES\n#define MAX_NUM_POINT_LIGHTS 100\n\n\n///////////////////////////////////////////////////////////\nstruct Material\n{\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float occlusion;\n    float reflectivity;\n    bool hasDiffTexture;\n    bool hasSpecTexture;\n    bool hasNormalTexture;\n};\n\n\n///////////////////////////////////////////////////////////\nstruct DirLight\n{\n    vec3 diffuse;\n    vec3 specular;\n    vec3 direction;\n};\n\n\n///////////////////////////////////////////////////////////\nstruct PointLight\n{\n    vec3 position;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 coefficients;\n};\n\n\n///////////////////////////////////////////////////////////\nlayout (std140) uniform Lights\n{\n    uniform vec3 u_ambient;\n\n    uniform DirLight u_dirLights[MAX_NUM_DIR_LIGHTS];\n    uniform PointLight u_pointLights[MAX_NUM_POINT_LIGHTS];\n    uniform int u_numDirLights;\n    uniform int u_numPointLights;\n};\n\n\n///////////////////////////////////////////////////////////\nvec3 calcDirLight(DirLight light, Material material, vec3 viewDir, vec3 normal, float shadowFactor, float diffFactor)\n{\n    // Get diffuse factor\n    float diff = dot(normal, -light.direction);\n    float diff1 = diffFactor * diff + diffFactor;\n    float diff2 = (1.0f - diffFactor) * diff + diffFactor;\n    if (diff < 0.0f)\n        diff = diff1;\n    else\n        diff = mix(diff1, diff2, shadowFactor);\n    diff = mix(1.0f, diff, material.occlusion);\n        \n    // Diffuse color\n    vec3 diffuse = diff * light.diffuse * material.diffuse;\n\n    // Get specular factor\n    vec3 reflectDir = reflect(-light.direction, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0f), material.shininess);\n\n    // Specular color\n    vec3 specular = spec * light.specular * material.specular * shadowFactor;\n\n    return diffuse + specular;\n}\n\n\n///////////////////////////////////////////////////////////\nvec3 calcPointLight(PointLight light, Material material, vec3 viewDir, vec3 fragPos, vec3 normal, float diffFactor)\n{\n    vec3 lightDir = fragPos - light.position;\n    float radius = length(lightDir);\n    lightDir /= radius;\n\n    // Calculate attenuation\n    float attenuation = 1.0f / (light.coefficients.x + light.coefficients.y * radius + light.coefficients.z * radius * radius);\n\n    // Get diffuse factor\n    float diff = dot(normal, -lightDir);\n    float diff1 = diffFactor * diff + diffFactor;\n    float diff2 = (1.0f - diffFactor) * diff + diffFactor;\n    diff = (diff < 0.0f ? diff1 : diff2);\n    diff = mix(1.0f, diff, material.occlusion);\n        \n    // Diffuse color\n    vec3 diffuse = diff * light.diffuse * material.diffuse;\n\n    // Get specular factor\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0f), material.shininess);\n\n    // Specular color\n    vec3 specular = spec * light.specular * material.specular;\n\n    return (diffuse + specular) * attenuation;\n}\nlayout (std140) uniform Shadows\n{\n    uniform mat4 u_lightProjViews[MAX_NUM_SHADOW_MAPS];\n    uniform float u_shadowDists[MAX_NUM_SHADOW_MAPS];\n    uniform float u_shadowStrengths[MAX_NUM_DIR_LIGHTS];\n    uniform int u_numShadowCascades[MAX_NUM_DIR_LIGHTS];\n    uniform bool u_shadowsEnabled[MAX_NUM_DIR_LIGHTS];\n};\n\n// Set up shadows in the vertex shader\n\n///////////////////////////////////////////////////////////\n\n#ifndef DEFERRED_SHADING\nout vec4 v_clipSpacePos;\nout vec4 v_lightClipSpacePos[MAX_NUM_SHADOW_MAPS];\n#else\nvec4 v_clipSpacePos;\nvec4 v_lightClipSpacePos[MAX_NUM_SHADOW_MAPS];\n#endif\n\n\n///////////////////////////////////////////////////////////\nvoid calcShadowClipSpace(vec4 worldPos)\n{\n    #ifndef DEFERRED_SHADING\n    v_clipSpacePos = gl_Position;\n    #else\n    v_clipSpacePos = u_projView * worldPos;\n    #endif\n\n    // Calculate light space positions\n    for (int i = 0; i < MAX_NUM_DIR_LIGHTS; ++i)\n    {\n        if (u_shadowsEnabled[i])\n        {\n            int start = i * MAX_NUM_SHADOW_CASCADES;\n            int end = start + MAX_NUM_SHADOW_CASCADES;\n\n            for (int j = start; j < end; ++j)\n                v_lightClipSpacePos[j] = u_lightProjViews[j] * worldPos;\n        }\n    }\n}\n///////////////////////////////////////////////////////////\nfloat rand(float c){\n	return fract(sin(c * 12.9898) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat rand(vec2 c){\n	return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n///////////////////////////////////////////////////////////\nvec2 rand2(vec2 st){\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n\n///////////////////////////////////////////////////////////\nvec3 rand3(vec3 st){\n    st = vec3(dot(st, vec3(127.1, 311.7, 285.1)),\n              dot(st, vec3(269.5, 183.3, 161.3)),\n              dot(st, vec3(345.3, 102.9, 245.5)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n\n///////////////////////////////////////////////////////////\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( rand2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( rand2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( rand2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( rand2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// Shadow functions in the fragment shader\n\n///////////////////////////////////////////////////////////\n\n#ifndef DEFERRED_SHADING\nin vec4 v_clipSpacePos;\nin vec4 v_lightClipSpacePos[MAX_NUM_SHADOW_MAPS];\n#endif\n\nuniform sampler2D u_shadowMaps[MAX_NUM_SHADOW_MAPS];\n\n\n///////////////////////////////////////////////////////////\nfloat getShadowFactor(int lightNum, vec3 normal, int kernelSize)\n{\n    // Return full light if shadows disabled\n    if (!u_shadowsEnabled[lightNum])\n        return 1.0f;\n\n    int lightIndex = lightNum * MAX_NUM_SHADOW_CASCADES;\n\n    // Get correct light parameters\n    int numCascades = u_numShadowCascades[lightNum];\n    float clipSpaceDepth = v_clipSpacePos.z;\n\n    // Find which region the pixel is in\n    int regionNum = 0;\n    for (; regionNum < numCascades; ++regionNum)\n    {\n        if (clipSpaceDepth < u_shadowDists[lightNum * MAX_NUM_SHADOW_CASCADES + regionNum])\n            break;\n    }\n\n    if (regionNum >= numCascades)\n        return 1.0f;\n\n    int mapIndex = lightIndex + regionNum;\n    vec3 projCoords = v_lightClipSpacePos[mapIndex].xyz / v_lightClipSpacePos[mapIndex].w;\n    projCoords = projCoords * 0.5f + 0.5f;\n\n    // Get shadow map depth\n    float shadow = 0.0f;\n    int kernelHalfSize = (regionNum == 0 ? kernelSize / 2 : 0);\n    vec2 texelSize = 1.0f / textureSize(u_shadowMaps[mapIndex], 0);\n\n    for (int r = -kernelHalfSize; r <= kernelHalfSize; ++r)\n    {\n        for (int c = -kernelHalfSize; c <= kernelHalfSize; ++c)\n        {\n            vec2 texCoords = projCoords.xy / texelSize + vec2(c, r) * 2.0f;\n            vec2 offset = rand2(texCoords * 0.001f);\n            texCoords += (offset - 0.5f);\n\n            float mapDepth = texture(u_shadowMaps[mapIndex], texCoords * texelSize).r;\n            float shadowBias = 0.0001f * (u_shadowDists[mapIndex] / u_shadowDists[lightIndex]) * (2.0f - dot(normal, -u_dirLights[lightNum].direction));\n            shadow += mapDepth < projCoords.z - shadowBias ? 1.0f : 0.0f;\n        }\n    }\n\n    shadow /= pow(2 * kernelHalfSize + 1, 2.0f);\n    \n    return mix(1.0f, 1.0f - shadow, u_shadowStrengths[lightNum]);\n}\n\n\n///////////////////////////////////////////////////////////\nin vec2 v_texCoord;\n\nout vec4 f_color;\n\nuniform mat4 u_invProjView;\n\nuniform sampler2D u_normalShininess;\nuniform sampler2D u_albedoOcclusion;\nuniform sampler2D u_specularReflectivity;\nuniform sampler2D u_depth;\n\n\n///////////////////////////////////////////////////////////////////////////////\nvec3 getFragPos(vec2 uv, out float depth)\n{\n    depth = 2.0f * texture(u_depth, uv).r - 1.0f;\n    vec4 clipPos = vec4(2.0f * uv - 1.0f, depth, 1.0f);\n    vec4 pos = u_invProjView * clipPos;\n\n    return pos.xyz / pos.w;\n}\n\n\n///////////////////////////////////////////////////////////\nvoid main()\n{\n    vec4 normalShininess = texture(u_normalShininess, v_texCoord);\n    vec3 normal = normalShininess.xyz;\n    float depth = 0.0f;\n    vec3 position = getFragPos(v_texCoord, depth);\n\n    // Create the material\n    vec4 albedoOcclusion = texture(u_albedoOcclusion, v_texCoord);\n\n    Material material;\n    material.diffuse = albedoOcclusion.rgb;\n    material.specular = texture(u_specularReflectivity, v_texCoord).rgb;\n    material.shininess = normalShininess.w;\n    material.occlusion = albedoOcclusion.a;\n\n\n    // Calculate view direction\n    float fragDist = distance(position, u_cameraPos);\n    vec3 viewDir = (position - u_cameraPos) / fragDist;\n\n    // Calculate shadow variables\n    calcShadowClipSpace(vec4(position, 1.0f));\n        \n    // Calculate lighting\n    vec3 result = material.diffuse * u_ambient;\n    \n    // Calculate directional lighting\n    for (int i = 0; i < u_numDirLights; ++i)\n    {\n        float shadowFactor = getShadowFactor(i, normal, 3);\n        result += calcDirLight(u_dirLights[i], material, viewDir, normal, shadowFactor, 0.1f);\n    }\n    \n    // Calculate point lights\n    for (int i = 0; i < u_numPointLights; ++i)\n        result += calcPointLight(u_pointLights[i], material, viewDir, position, normal, 0.1f);\n\n    f_color = vec4(result, 1.0f);\n}"
#endif